{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["\"use strict\";\r\nimport * as utils from \"@iobroker/adapter-core\";\r\n\r\nimport {\r\n\tdoesAlexaSendAQuestion,\r\n\tisIobrokerValue,\r\n\tisCreateNewTimer as isNewTimerAction,\r\n\tisStateChanged,\r\n\tisVoiceInputNotSameAsOld,\r\n} from \"./lib/global\";\r\nimport { timerObject } from \"./lib/timer-data\";\r\nimport { useStore } from \"./store/store\";\r\nimport { setAdapterStatusAndInitStateCreation } from \"./lib/set-adapter-status\";\r\nimport { getToDo } from \"./lib/get-todo\";\r\nimport { delTimer } from \"./lib/delete-timer\";\r\nimport { decomposeInputValue } from \"./lib/decompose-input-value\";\r\nimport { compareCreationTimeAndSerial } from \"./lib/compare-serial\";\r\nimport { shouldDelete } from \"./lib/check-voice-input\";\r\nimport { extendOrShortTimer } from \"./lib/timer-extend-or-shorten\";\r\nimport { timerDelete } from \"./lib/timer-delete\";\r\nimport { timerAdd } from \"./lib/timer-add\";\r\nimport { writeState } from \"./lib/write-state\";\r\nimport { getNewTimerName } from \"./lib/timer-name\";\r\nimport { resetAllTimerValuesAndState } from \"./lib/reset\";\r\n\r\nlet timeout_1: ioBroker.Timeout | undefined;\r\nlet debounceTimeout: ioBroker.Timeout | undefined;\r\n\r\nexport default class AlexaTimerVis extends utils.Adapter {\r\n\tprivate static instance: AlexaTimerVis;\r\n\t/**\r\n\t * @param {Partial<utils.AdapterOptions>} [options={}]\r\n\t */\r\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\r\n\t\tsuper({\r\n\t\t\t...options,\r\n\t\t\tname: \"alexa-timer-vis\",\r\n\t\t});\r\n\t\tthis.on(\"ready\", this.onReady.bind(this));\r\n\t\tthis.on(\"unload\", this.onUnload.bind(this));\r\n\t\tAlexaTimerVis.instance = this;\r\n\t}\r\n\tpublic static getInstance(): AlexaTimerVis {\r\n\t\treturn AlexaTimerVis.instance;\r\n\t}\r\n\r\n\tprivate async onReady(): Promise<void> {\r\n\t\tconst store = useStore();\r\n\t\tstore._this = this;\r\n\r\n\t\tthis.setState(\"info.connection\", false, true);\r\n\r\n\r\n\r\n\t\tstore.pathAlexaSummary = `${this.config.alexa}.History.summary`;\r\n\r\n\t\tstore.intervalMore60 = this.config.intervall1;\r\n\t\tstore.intervalLess60 = this.config.intervall2;\r\n\r\n\t\tstore.unitHour1 = this.config.unitHour1;\r\n\t\tstore.unitHour2 = this.config.unitHour2;\r\n\t\tstore.unitHour3 = this.config.unitHour3;\r\n\t\tstore.unitMinute1 = this.config.unitMinute1;\r\n\t\tstore.unitMinute2 = this.config.unitMinute2;\r\n\t\tstore.unitMinute3 = this.config.unitMinute3;\r\n\t\tstore.unitSecond1 = this.config.unitSecond1;\r\n\t\tstore.unitSecond3 = this.config.unitSecond3;\r\n\t\tstore.unitSecond2 = this.config.unitSecond2;\r\n\r\n\t\tstore.valHourForZero = this.config.valHourForZero;\r\n\t\tstore.valMinuteForZero = this.config.valMinuteForZero;\r\n\t\tstore.valSecondForZero = this.config.valSecondForZero;\r\n\r\n\t\tstore.debounceTime = this.config.entprellZeit;\r\n\r\n\t\tawait setAdapterStatusAndInitStateCreation();\r\n\t\tresetAllTimerValuesAndState();\r\n\r\n\t\tlet voiceInputOld: null | string = null;\r\n\t\tlet voiceInput: string;\r\n\t\tlet timeVoiceInputOld: string | null = null;\r\n\r\n\t\tthis.on(\"stateChange\", async (id, state) => {\r\n\t\t\tcheckForTimerName(this);\r\n\r\n\t\t\tif (isStateChanged(state, id)) {\r\n\t\t\t\t// Bestimmte Aufrufe d\u00FCrfen keine Aktion ausf\u00FChren, wenn mehrere Ger\u00E4te zuh\u00F6ren. #12 und #14 .\r\n\t\t\t\tlet doNothingByNotNotedElement = false;\r\n\t\t\t\tvoiceInput = state?.val as string;\r\n\r\n\t\t\t\tif (timerObject.timerActive.data.notNotedSentence.find((el) => el === voiceInput)) {\r\n\t\t\t\t\tdoNothingByNotNotedElement = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isNewTimerAction(voiceInput)) {\r\n\t\t\t\t\tconst { varInputContainsDelete } = shouldDelete(voiceInput);\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tname: decomposeName,\r\n\t\t\t\t\t\ttimerSec,\r\n\t\t\t\t\t\tdeleteVal,\r\n\t\t\t\t\t\tinputString: decomposeInputString,\r\n\t\t\t\t\t} = await decomposeInputValue(voiceInput);\r\n\r\n\t\t\t\t\tconst { sameTime } = await compareCreationTimeAndSerial();\r\n\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t(!sameTime &&\r\n\t\t\t\t\t\t\tisVoiceInputNotSameAsOld(voiceInput, voiceInputOld) &&\r\n\t\t\t\t\t\t\t!doNothingByNotNotedElement &&\r\n\t\t\t\t\t\t\ttimeVoiceInputOld != timerSec.toString()) ||\r\n\t\t\t\t\t\tvarInputContainsDelete\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tvoiceInputOld = voiceInput;\r\n\t\t\t\t\t\ttimeVoiceInputOld = timerSec.toString();\r\n\r\n\t\t\t\t\t\tthis.clearTimeout(debounceTimeout);\r\n\r\n\t\t\t\t\t\tdebounceTimeout = this.setTimeout(() => {\r\n\t\t\t\t\t\t\tvoiceInputOld = null;\r\n\t\t\t\t\t\t\ttimeVoiceInputOld = null;\r\n\t\t\t\t\t\t\tthis.log.debug(\"Reset ValueOld\");\r\n\t\t\t\t\t\t}, store.debounceTime * 1000);\r\n\r\n\t\t\t\t\t\tdoesAlexaSendAQuestion(voiceInput);\r\n\t\t\t\t\t\tgetToDo(voiceInput);\r\n\r\n\t\t\t\t\t\tif (store.isDeleteTimer()) {\r\n\t\t\t\t\t\t\ttimerDelete(decomposeName, timerSec, voiceInput, deleteVal);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (store.isAddTimer()) {\r\n\t\t\t\t\t\t\ttimerAdd(decomposeName, timerSec, decomposeInputString);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (store.isExtendTimer() || store.isShortenTimer()) {\r\n\t\t\t\t\t\t\textendOrShortTimer({ voiceInput, decomposeName });\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Auf Button reagieren\r\n\t\t\t} else if (\r\n\t\t\t\tid != `alexa-timer-vis.${this.instance}.info.connection` &&\r\n\t\t\t\tstate &&\r\n\t\t\t\tstate.val !== false &&\r\n\t\t\t\tid != \"alexa2.0.History.summary\"\r\n\t\t\t) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tthis.log.info(\"Reset Button has been clicked: \" + JSON.stringify(id));\r\n\t\t\t\t\t// Aus ID den Timer erfassen\r\n\t\t\t\t\tconst timer = id.split(\".\")[2];\r\n\r\n\t\t\t\t\tconst timerOb = timerObject.timer[timer as keyof typeof timerObject.timer];\r\n\t\t\t\t\tlet alexaCommandState;\r\n\r\n\t\t\t\t\tif (timerOb?.serialNumber != undefined) {\r\n\t\t\t\t\t\talexaCommandState = `alexa2.${store.getAlexaInstanceObject().instance}.Echo-Devices.${timerOb.serialNumber}.Commands.textCommand`;\r\n\t\t\t\t\t\tlet name = \"\";\r\n\t\t\t\t\t\t// Wenn der Name ungleich nur \"Timer\" ist soll dieser mit ausgegeben werden\r\n\t\t\t\t\t\tif (timerOb.name != \"Timer\") name = timerOb.name;\r\n\r\n\t\t\t\t\t\t// TODO: Timer stoppen war vorher timerOb.inputString\r\n\t\t\t\t\t\tconst alexaTextToCommand = `stoppe ${name} ${timerOb.timerInput} Timer`;\r\n\t\t\t\t\t\t// Alexa State setzen, Alexa gibt dadurch eine Sprachausgabe\r\n\t\t\t\t\t\tdelTimer(timer as keyof typeof timerObject.timerActive.timer);\r\n\t\t\t\t\t\tthis.setForeignState(alexaCommandState, alexaTextToCommand, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tthis.log.error(\"Serial Error: \" + JSON.stringify(e));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction checkForTimerName(_this: AlexaTimerVis): void {\r\n\t\t\t\tlet timerSelector = \"\";\r\n\t\t\t\tif (\r\n\t\t\t\t\tstore.lastTimers.find((el) => {\r\n\t\t\t\t\t\tif (el.id === id) {\r\n\t\t\t\t\t\t\ttimerSelector = el.timerSelector;\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t})\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (isIobrokerValue(state)) {\r\n\t\t\t\t\t\tgetNewTimerName(state, timerSelector);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstore.lastTimers = store.lastTimers.filter((el) => el.id !== id);\r\n\t\t\t\t\t_this.unsubscribeForeignStatesAsync(id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.subscribeForeignStates(store.pathAlexaSummary);\r\n\t}\r\n\r\n\tonUnload(callback: () => void): void {\r\n\t\tconst store = useStore();\r\n\t\ttry {\r\n\t\t\tthis.log.info(\"Adapter shuts down\");\r\n\r\n\t\t\twriteState(true);\r\n\r\n\t\t\tthis.clearTimeout(timeout_1);\r\n\t\t\tthis.clearTimeout(debounceTimeout);\r\n\r\n\t\t\tthis.clearInterval(store.interval);\r\n\r\n\t\t\tif (!timerObject.interval) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tfor (const element in timerObject.interval) {\r\n\t\t\t\tthis.clearInterval(timerObject.interval[element as keyof typeof timerObject.interval]);\r\n\t\t\t}\r\n\r\n\t\t\tthis.log.debug(\"Intervals and timeouts cleared!\");\r\n\r\n\t\t\tcallback();\r\n\t\t} catch (e) {\r\n\t\t\tcallback();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlet adapter;\r\nif (require.main !== module) {\r\n\t// Export the constructor in compact mode\r\n\tadapter = (options: Partial<utils.AdapterOptions> | undefined) => new AlexaTimerVis(options);\r\n} else {\r\n\t// otherwise start the instance directly\r\n\t(() => new AlexaTimerVis())();\r\n}\r\nexport { adapter };\r\n"],
  "mappings": "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",
  "names": ["isNewTimerAction"]
}
