{
  "version": 3,
  "sources": ["../../src/lib/find-timer.ts"],
  "sourcesContent": ["import { useStore } from \"../store/store\";\nimport { timerObject } from \"./timer-data\";\nimport { isIobrokerValue, isString } from \"./global\";\nimport { errorLogging } from \"./logging\";\n\nexport const findTimer = async (\n\tsec: number,\n\tname: string,\n\tdeleteTimerIndex: number,\n\tvalue: string,\n): Promise<{ oneOfMultiTimer: any[]; timer: string[] }> => {\n\tconst store = useStore();\n\tconst _this = store._this;\n\ttry {\n\t\tname = name.trim();\n\t\t//TODO: Refactor\n\t\tlet inputDevice = \"\";\n\n\t\tconst obj = await _this.getForeignStateAsync(`alexa2.${store.getAlexaInstanceObject().instance}.History.name`);\n\n\t\tif (isIobrokerValue(obj) && isString(obj.val)) {\n\t\t\tinputDevice = obj.val;\n\t\t}\n\n\t\tconst { countMatchingName, countMatchingTime, countMatchingInputDevice } = getMatchingTimerCounts(\n\t\t\tinputDevice,\n\t\t\tsec,\n\t\t\tname,\n\t\t);\n\n\t\tconst timerFound: { oneOfMultiTimer: any[]; timer: any[] } = { oneOfMultiTimer: [], timer: [] };\n\n\t\tif (store.questionAlexa) {\n\t\t\tif (countMatchingName == 1) {\n\t\t\t\tconst value = \"\";\n\t\t\t\tconst sec = 0;\n\n\t\t\t\ttimerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n\t\t\t}\n\n\t\t\t// Einer, mit genauer Zeit, mehrmals vorhanden\n\t\t\telse if (countMatchingTime > 1) {\n\t\t\t\tconst name = \"\";\n\t\t\t\tconst inputDevice = \"\";\n\n\t\t\t\ttimerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n\t\t\t}\n\t\t\t// Einer, mit genauer Zeit, mehrmals auf verschiedenen Ger\u00E4ten\n\t\t\telse if (countMatchingInputDevice != timerObject.timerActive.timerCount) {\n\t\t\t\tconst name = \"\";\n\t\t\t\tconst inputDevice = \"\";\n\n\t\t\t\ttimerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n\t\t\t} else {\n\t\t\t\tconst sec = 0;\n\t\t\t\tconst name = \"\";\n\t\t\t\tconst inputDevice = \"\";\n\n\t\t\t\ttimerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n\t\t\t}\n\t\t}\n\n\t\tfor (const element in timerObject.timer) {\n\t\t\t// Soll einer oder mehrere Timer gel\u00F6scht werden?\n\t\t\tif (deleteTimerIndex == 1) {\n\t\t\t\t// Einer, mit genauer Zeit, nur einmal vorhanden\n\t\t\t\t// Einer, und einer ist auch nur gestellt\n\t\t\t\tif (!store.questionAlexa) {\n\t\t\t\t\tif (\n\t\t\t\t\t\ttimerObject.timerActive.timerCount == 1 &&\n\t\t\t\t\t\ttimerObject.timerActive.timer[element as keyof typeof timerObject.timer] === true\n\t\t\t\t\t) {\n\t\t\t\t\t\ttimerFound.timer.push(element);\n\t\t\t\t\t\t// _this.log.debug(\"Einer, wenn genau einer gestellt ist\");\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tcountMatchingTime == 1 &&\n\t\t\t\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer][\"voiceInputAsSeconds\"] == sec &&\n\t\t\t\t\t\tsec !== 0\n\t\t\t\t\t) {\n\t\t\t\t\t\ttimerFound.timer.push(element);\n\n\t\t\t\t\t\t// _this.log.debug(\"Wenn nur einer gestellt ist mit der der gew\u00FCnschten Zeit\");\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tcountMatchingTime == 1 &&\n\t\t\t\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer][\"voiceInputAsSeconds\"] == sec\n\t\t\t\t\t) {\n\t\t\t\t\t\ttimerFound.timer.push(element);\n\t\t\t\t\t\t// _this.log.debug(\"Einer ist gestellt mit genau diesem Wert\");\n\t\t\t\t\t}\n\t\t\t\t\t// Einer, mit genauem Namen\n\t\t\t\t\telse if (\n\t\t\t\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer][\"name\"] == name &&\n\t\t\t\t\t\tname !== \"\" &&\n\t\t\t\t\t\tcountMatchingName == 1\n\t\t\t\t\t) {\n\t\t\t\t\t\ttimerFound.timer.push(element);\n\n\t\t\t\t\t\t// _this.log.debug(\"Mit genauem Namen\");\n\t\t\t\t\t} // Entweder alle auf diesem Ger\u00E4t, oder keins auf diesem Ger\u00E4t\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t} else if (deleteTimerIndex == 2) {\n\t\t\t\t// Alle, alle sind auf einem Ger\u00E4t\n\t\t\t\tif (!store.questionAlexa) {\n\t\t\t\t\ttimerFound.timer.push(element);\n\t\t\t\t\t// }\n\t\t\t\t} else {\n\t\t\t\t\t// Alle, nur die vom eingabe Ger\u00E4t\n\t\t\t\t\tif (countMatchingInputDevice != timerObject.timerActive.timerCount && value.indexOf(\"nein\") != -1) {\n\t\t\t\t\t\tif (timerObject.timer[element as keyof typeof timerObject.timer].inputDevice == inputDevice) {\n\t\t\t\t\t\t\ttimerFound.timer.push(element);\n\t\t\t\t\t\t\t// _this.log.debug(\"Only this device\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Alle, von allen Ger\u00E4ten\n\t\t\t\t\telse if (\n\t\t\t\t\t\tcountMatchingInputDevice != timerObject.timerActive.timerCount &&\n\t\t\t\t\t\tvalue.indexOf(\"ja\") != -1\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (const element in timerObject.timerActive.timer) {\n\t\t\t\t\t\t\ttimerFound.timer.push(element);\n\t\t\t\t\t\t\t_this.log.debug(\"Clear all\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn timerFound;\n\t} catch (e) {\n\t\terrorLogging({ text: \"Error in findTimer\", error: e, _this });\n\t\treturn { oneOfMultiTimer: [], timer: [] };\n\t}\n};\n\nfunction findTimerWithExactSameInputDevice(\n\telement: string,\n\tinputDevice: string,\n\tcountMatchingInputDevice: number,\n): number {\n\tif (timerObject.timer[element as keyof typeof timerObject.timer].inputDevice == inputDevice) {\n\t\tcountMatchingInputDevice++;\n\t}\n\treturn countMatchingInputDevice;\n}\n\nfunction findTimerWithExactSameName(element: string, countMatchingName: number, name: string): number {\n\tif (timerObject.timer[element as keyof typeof timerObject.timer].name.trim() == name) {\n\t\tcountMatchingName++;\n\t}\n\treturn countMatchingName;\n}\n\nfunction findTimerWithExactSameSec(element: string, countMatchingTime: number, sec: number): number {\n\tif (timerObject.timer[element as keyof typeof timerObject.timer].voiceInputAsSeconds == sec) {\n\t\tcountMatchingTime++;\n\t}\n\treturn countMatchingTime;\n}\n\nfunction getMatchingTimerCounts(\n\tinputDevice: string,\n\tsec: number,\n\tname: string,\n): { countMatchingName: number; countMatchingTime: number; countMatchingInputDevice: number } {\n\tlet countMatchingTime = 0;\n\tlet countMatchingName = 0;\n\tlet countMatchingInputDevice = 0;\n\n\tfor (const element in timerObject.timer) {\n\t\tcountMatchingTime = findTimerWithExactSameSec(element, countMatchingTime, sec);\n\t\tcountMatchingName = findTimerWithExactSameName(element, countMatchingName, name);\n\t\tcountMatchingInputDevice = findTimerWithExactSameInputDevice(element, inputDevice, countMatchingInputDevice);\n\t}\n\treturn { countMatchingName, countMatchingTime, countMatchingInputDevice };\n}\n"],
  "mappings": "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",
  "names": ["value", "sec", "name", "inputDevice", "element"]
}
