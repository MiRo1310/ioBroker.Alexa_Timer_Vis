{
  "version": 3,
  "sources": ["../../src/lib/find-timer.ts"],
  "sourcesContent": ["import { useStore } from '../store/store';\nimport { timerObject } from './timer-data';\nimport { isIobrokerValue, isString } from './global';\nimport { errorLogging } from './logging';\n\nexport const findTimer = async (\n    sec: number,\n    name: string,\n    deleteTimerIndex: number,\n    value: string,\n): Promise<{ oneOfMultiTimer: any[]; timer: string[] }> => {\n    const store = useStore();\n    const _this = store._this;\n    try {\n        name = name.trim();\n        //TODO: Refactor\n        let inputDevice = '';\n\n        const obj = await _this.getForeignStateAsync(`alexa2.${store.getAlexaInstanceObject().instance}.History.name`);\n\n        if (isIobrokerValue(obj) && isString(obj.val)) {\n            inputDevice = obj.val;\n        }\n\n        const { countMatchingName, countMatchingTime, countMatchingInputDevice } = getMatchingTimerCounts(\n            inputDevice,\n            sec,\n            name,\n        );\n\n        const timerFound: {\n            oneOfMultiTimer: any[];\n            timer: any[];\n        } = { oneOfMultiTimer: [], timer: [] };\n\n        if (store.questionAlexa) {\n            if (countMatchingName == 1) {\n                const value = '';\n                const sec = 0;\n\n                timerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n            } else if (countMatchingTime > 1) {\n                // Einer, mit genauer Zeit, mehrmals vorhanden\n                const name = '';\n                const inputDevice = '';\n\n                timerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n            } else if (countMatchingInputDevice != timerObject.timerActive.timerCount) {\n                // Einer, mit genauer Zeit, mehrmals auf verschiedenen Ger\u00E4ten\n                const name = '';\n                const inputDevice = '';\n\n                timerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n            } else {\n                const sec = 0;\n                const name = '';\n                const inputDevice = '';\n\n                timerFound.oneOfMultiTimer = [value, sec, name, inputDevice];\n            }\n        }\n\n        for (const element in timerObject.timer) {\n            // Soll einer oder mehrere Timer gel\u00F6scht werden?\n            if (deleteTimerIndex == 1) {\n                // Einer, mit genauer Zeit, nur einmal vorhanden\n                // Einer, und einer ist auch nur gestellt\n                if (!store.questionAlexa) {\n                    if (\n                        timerObject.timerActive.timerCount == 1 &&\n                        timerObject.timerActive.timer[element as keyof typeof timerObject.timer]\n                    ) {\n                        timerFound.timer.push(element);\n                        // _this.log.debug(\"Einer, wenn genau einer gestellt ist\");\n                    } else if (\n                        countMatchingTime == 1 &&\n                        timerObject.timer[element as keyof typeof timerObject.timer].voiceInputAsSeconds == sec &&\n                        sec !== 0\n                    ) {\n                        timerFound.timer.push(element);\n                    } else if (\n                        // _this.log.debug(\"Wenn nur einer gestellt ist mit der der gew\u00FCnschten Zeit\");\n                        countMatchingTime == 1 &&\n                        timerObject.timer[element as keyof typeof timerObject.timer].voiceInputAsSeconds == sec\n                    ) {\n                        timerFound.timer.push(element);\n                        // _this.log.debug(\"Einer ist gestellt mit genau diesem Wert\");\n                    } else if (\n                        // Einer, mit genauem Namen\n                        timerObject.timer[element as keyof typeof timerObject.timer].name == name &&\n                        name !== '' &&\n                        countMatchingName == 1\n                    ) {\n                        timerFound.timer.push(element);\n\n                        // _this.log.debug(\"Mit genauem Namen\");\n                    } // Entweder alle auf diesem Ger\u00E4t, oder keins auf diesem Ger\u00E4t\n                    // }\n                }\n            } else if (deleteTimerIndex == 2) {\n                // Alle, alle sind auf einem Ger\u00E4t\n                if (!store.questionAlexa) {\n                    timerFound.timer.push(element);\n                    // }\n                } else {\n                    // Alle, nur die vom eingabe Ger\u00E4t\n                    if (countMatchingInputDevice != timerObject.timerActive.timerCount && value.indexOf('nein') != -1) {\n                        if (timerObject.timer[element as keyof typeof timerObject.timer].inputDevice == inputDevice) {\n                            timerFound.timer.push(element);\n                            // _this.log.debug(\"Only this device\");\n                        }\n                    } else if (\n                        // Alle, von allen Ger\u00E4ten\n                        countMatchingInputDevice != timerObject.timerActive.timerCount &&\n                        value.indexOf('ja') != -1\n                    ) {\n                        for (const element in timerObject.timerActive.timer) {\n                            timerFound.timer.push(element);\n                            _this.log.debug('Clear all');\n                        }\n                    }\n                }\n            }\n        }\n        return timerFound;\n    } catch (e) {\n        errorLogging({ text: 'Error in findTimer', error: e, _this });\n        return { oneOfMultiTimer: [], timer: [] };\n    }\n};\n\nfunction findTimerWithExactSameInputDevice(\n    element: string,\n    inputDevice: string,\n    countMatchingInputDevice: number,\n): number {\n    if (timerObject.timer[element as keyof typeof timerObject.timer].inputDevice == inputDevice) {\n        countMatchingInputDevice++;\n    }\n    return countMatchingInputDevice;\n}\n\nfunction findTimerWithExactSameName(element: string, countMatchingName: number, name: string): number {\n    if (timerObject.timer[element as keyof typeof timerObject.timer].name.trim() == name) {\n        countMatchingName++;\n    }\n    return countMatchingName;\n}\n\nfunction findTimerWithExactSameSec(element: string, countMatchingTime: number, sec: number): number {\n    if (timerObject.timer[element as keyof typeof timerObject.timer].voiceInputAsSeconds == sec) {\n        countMatchingTime++;\n    }\n    return countMatchingTime;\n}\n\nfunction getMatchingTimerCounts(\n    inputDevice: string,\n    sec: number,\n    name: string,\n): { countMatchingName: number; countMatchingTime: number; countMatchingInputDevice: number } {\n    let countMatchingTime = 0;\n    let countMatchingName = 0;\n    let countMatchingInputDevice = 0;\n\n    for (const element in timerObject.timer) {\n        countMatchingTime = findTimerWithExactSameSec(element, countMatchingTime, sec);\n        countMatchingName = findTimerWithExactSameName(element, countMatchingName, name);\n        countMatchingInputDevice = findTimerWithExactSameInputDevice(element, inputDevice, countMatchingInputDevice);\n    }\n    return { countMatchingName, countMatchingTime, countMatchingInputDevice };\n}\n"],
  "mappings": "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",
  "names": ["value", "sec", "name", "inputDevice", "element"]
}
