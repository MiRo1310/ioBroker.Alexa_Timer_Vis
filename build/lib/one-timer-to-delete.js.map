{
  "version": 3,
  "sources": ["../../src/lib/one-timer-to-delete.ts"],
  "sourcesContent": ["import { timerObject } from \"./timer-data\";\nimport { sortArray } from \"./global\";\n\nexport const oneOfMultiTimerDelete = (input: string, timeSec: number, name: string, inputDevice: string): void => {\n\tconst separateInput = input.slice(input.indexOf(\",\") + 2, input.length);\n\n\tconst separateInputArray = separateInput.split(\" \");\n\tlet timerNumber;\n\n\t// \u00DCber pr\u00FCfen ob die Antwort eine Zahl ist oder ein Name\n\tfor (const element of separateInputArray) {\n\t\tif (timerObject.zuweisung[element as keyof typeof timerObject.zuweisung] > 0) {\n\t\t\t// Es handelt sich um eine Zahl die im Array gefunden wurde\n\n\t\t\ttimerNumber = timerObject.zuweisung[element as keyof typeof timerObject.zuweisung];\n\t\t} else {\n\t\t\tname = separateInput.replace(\"timer\", \"\").trim();\n\t\t\ttimerNumber = 0;\n\t\t}\n\t}\n\n\tlet sortable = [];\n\tfor (const element in timerObject.timer) {\n\t\tsortable.push([\n\t\t\telement,\n\n\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer].voiceInputAsSeconds,\n\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer].remainingTimeInSeconds,\n\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer].name,\n\t\t\ttimerObject.timer[element as keyof typeof timerObject.timer].inputDevice,\n\t\t]);\n\t}\n\n\tsortable = sortArray(sortable); // Das Array in dem die Timer sind nach der Gr\u00F6\u00DFe sortieren und dann das entsprechende Element stoppen\n\n\tlet i = 1;\n\n\tfor (const element of sortable) {\n\t\tif (element[1] == timeSec && timerNumber == i) {\n\t\t\t// Auf Zeit \u00FCberpr\u00FCfen\n\t\t\ttimerObject.timerActive.timer[element[0] as keyof typeof timerObject.timerActive.timer] = false;\n\t\t\tbreak;\n\t\t} // Auf Name \u00FCberpr\u00FCfen\n\t\telse if (element[3] == name && timerNumber == i) {\n\t\t\ttimerObject.timerActive.timer[element[0] as keyof typeof timerObject.timerActive.timer] = false;\n\t\t\tbreak;\n\t\t} // Auf Name \u00FCberpr\u00FCfen, wenn der Name in der Antwort vor kam\n\t\telse if (element[3] == name && timerNumber == 0) {\n\t\t\ttimerObject.timerActive.timer[element[0] as keyof typeof timerObject.timerActive.timer] = false;\n\t\t\tbreak;\n\t\t} // Auf Device \u00FCberpr\u00FCfen\n\t\telse if (element[4] == inputDevice && timerNumber == i) {\n\t\t\ttimerObject.timerActive.timer[element[0] as keyof typeof timerObject.timerActive.timer] = false;\n\t\t\tbreak;\n\t\t} // Wenn kein Angaben vor liegen\n\t\telse if (inputDevice == \"\" && timeSec == 0 && name == \"\" && timerNumber == i) {\n\t\t\ttimerObject.timerActive.timer[element[0] as keyof typeof timerObject.timerActive.timer] = false;\n\t\t\tbreak;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA4B;AAC5B,oBAA0B;AAEnB,MAAM,wBAAwB,CAAC,OAAe,SAAiB,MAAc,gBAA8B;AACjH,QAAM,gBAAgB,MAAM,MAAM,MAAM,QAAQ,GAAG,IAAI,GAAG,MAAM,MAAM;AAEtE,QAAM,qBAAqB,cAAc,MAAM,GAAG;AAClD,MAAI;AAGJ,aAAW,WAAW,oBAAoB;AACzC,QAAI,8BAAY,UAAU,OAA6C,IAAI,GAAG;AAG7E,oBAAc,8BAAY,UAAU,OAA6C;AAAA,IAClF,OAAO;AACN,aAAO,cAAc,QAAQ,SAAS,EAAE,EAAE,KAAK;AAC/C,oBAAc;AAAA,IACf;AAAA,EACD;AAEA,MAAI,WAAW,CAAC;AAChB,aAAW,WAAW,8BAAY,OAAO;AACxC,aAAS,KAAK;AAAA,MACb;AAAA,MAEA,8BAAY,MAAM,OAAyC,EAAE;AAAA,MAC7D,8BAAY,MAAM,OAAyC,EAAE;AAAA,MAC7D,8BAAY,MAAM,OAAyC,EAAE;AAAA,MAC7D,8BAAY,MAAM,OAAyC,EAAE;AAAA,IAC9D,CAAC;AAAA,EACF;AAEA,iBAAW,yBAAU,QAAQ;AAE7B,MAAI,IAAI;AAER,aAAW,WAAW,UAAU;AAC/B,QAAI,QAAQ,CAAC,KAAK,WAAW,eAAe,GAAG;AAE9C,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAA+C,IAAI;AAC1F;AAAA,IACD,WACS,QAAQ,CAAC,KAAK,QAAQ,eAAe,GAAG;AAChD,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAA+C,IAAI;AAC1F;AAAA,IACD,WACS,QAAQ,CAAC,KAAK,QAAQ,eAAe,GAAG;AAChD,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAA+C,IAAI;AAC1F;AAAA,IACD,WACS,QAAQ,CAAC,KAAK,eAAe,eAAe,GAAG;AACvD,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAA+C,IAAI;AAC1F;AAAA,IACD,WACS,eAAe,MAAM,WAAW,KAAK,QAAQ,MAAM,eAAe,GAAG;AAC7E,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAA+C,IAAI;AAC1F;AAAA,IACD,OAAO;AACN;AAAA,IACD;AAAA,EACD;AACD;",
  "names": []
}
